Max Sum without Adjacents (4min)


class Solution {
  public:
    // calculate the maximum sum with out adjacent
    int solve(vector<int>&v , int i ,vector<int>&dp){
        if(i>=v.size()){
            return 0;
        }
        if(dp[i]!=-1){
            return dp[i];
        }
        return dp[i]= max( v[i]+solve(v, i+2,dp) ,solve(v,i+1,dp));
    }
    int findMaxSum(vector<int>& arr) {
        // code here
        vector<int>dp(arr.size()+2 ,-1);
        return solve(arr, 0 ,dp);
    }
};


746. Min Cost Climbing Stairs (6 min)

class Solution {
public:
    int solve(vector<int>&cost , int i ,vector<int>& dp){
        if(i>=cost.size()){
            return 0;
        }
        if(dp[i]!=-1) return dp[i];
        return dp[i]=cost[i]+ min(solve(cost, i+1,dp) , solve(cost,i+2,dp));
    }
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size()+1, -1);
        return min(solve(cost,0,dp) , solve(cost, 1,dp));
    }
};

Climbing Stairs (4min)
class Solution {
public:
    int solve(int i ,int n , vector<int>&dp){
        if(i>=n){
           
            return 1;
        }
        if(dp[i]!=-1) return dp[i];
        return dp[i]= solve(i+1 ,n,dp)+ solve(i+2 , n,dp);
    }
    int climbStairs(int n) {
        vector<int>dp(n+1 , -1);
        return solve(1, n , dp);
    }
};

MST1 - Minimum Step To One
no tags 

Problem statement is very easy. On a positive integer, you can perform any one of the following 3 steps.
Subtract 1 from it. (n = n - 1)
If it is divisible by 2, divide by 2. (if n % 2 == 0, then n = n / 2)
If it is divisible by 3, divide by 3. (if n % 3 == 0, then n = n / 3)
#include <bits/stdc++.h>
using namespace std;
int solve(int n){
    // cout<<n<<" ";
	if(n<=1){
		return 0;
	}
	int a=INT_MAX;
	
	if(n%3==0){
		a =solve(n/3);
	}
	int b=INT_MAX;
	if(n%2==0){
		b= solve(n/2);
	}
	return 1+ min(a,min(b, solve(n-1)));
	
}
int main() {
	// your code goes here
	int n;
	cin>>n;
	cout<<solve(n);
	return 0;
}
