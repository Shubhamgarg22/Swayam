Max Sum without Adjacents (4min)


class Solution {
  public:
    // calculate the maximum sum with out adjacent
    int solve(vector<int>&v , int i ,vector<int>&dp){
        if(i>=v.size()){
            return 0;
        }
        if(dp[i]!=-1){
            return dp[i];
        }
        return dp[i]= max( v[i]+solve(v, i+2,dp) ,solve(v,i+1,dp));
    }
    int findMaxSum(vector<int>& arr) {
        // code here
        vector<int>dp(arr.size()+2 ,-1);
        return solve(arr, 0 ,dp);
    }
};


746. Min Cost Climbing Stairs (6 min)

class Solution {
public:
    int solve(vector<int>&cost , int i ,vector<int>& dp){
        if(i>=cost.size()){
            return 0;
        }
        if(dp[i]!=-1) return dp[i];
        return dp[i]=cost[i]+ min(solve(cost, i+1,dp) , solve(cost,i+2,dp));
    }
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size()+1, -1);
        return min(solve(cost,0,dp) , solve(cost, 1,dp));
    }
};

Climbing Stairs (4min)
class Solution {
public:
    int solve(int i ,int n , vector<int>&dp){
        if(i>=n){
           
            return 1;
        }
        if(dp[i]!=-1) return dp[i];
        return dp[i]= solve(i+1 ,n,dp)+ solve(i+2 , n,dp);
    }
    int climbStairs(int n) {
        vector<int>dp(n+1 , -1);
        return solve(1, n , dp);
    }
};

MST1 - Minimum Step To One
no tags 

Problem statement is very easy. On a positive integer, you can perform any one of the following 3 steps.
Subtract 1 from it. (n = n - 1)
If it is divisible by 2, divide by 2. (if n % 2 == 0, then n = n / 2)
If it is divisible by 3, divide by 3. (if n % 3 == 0, then n = n / 3)
#include <bits/stdc++.h>
using namespace std;
int solve(int n){
    // cout<<n<<" ";
	if(n<=1){
		return 0;
	}
	int a=INT_MAX;
	
	if(n%3==0){
		a =solve(n/3);
	}
	int b=INT_MAX;
	if(n%2==0){
		b= solve(n/2);
	}
	return 1+ min(a,min(b, solve(n-1)));
	
}
int main() {
	// your code goes here
	int n;
	cin>>n;
	cout<<solve(n);
	return 0;
}
416. Partition Equal Subset Sum (8 min)

class Solution {
public:
    bool solve(vector<int>&nums , int i ,int sum , vector<vector<int>>&dp){
        if(i>=nums.size()) return false;
        if(sum==0) return true;
        if(sum<0) return false ;
        if(dp[i][sum]!=-1){
            return dp[i][sum];
        }
        return dp[i][sum]=solve(nums,i+1 ,sum,dp) || solve(nums ,i+1 ,sum-nums[i],dp);
    }
    bool canPartition(vector<int>& nums) {
        int sum=0;
        for(auto x:nums) sum+=x;
        if(sum%2==1) return false;
        sum/=2;
        vector<vector<int>>dp(nums.size()+2 ,vector<int>(sum+2,-1));
        return solve(nums , 0 , sum,dp);

    }
};

62. Unique Paths(4 min)
class Solution {
public:
    int solve(int m ,int n ,vector<vector<int>>&dp){
       
        if(m==1 || n==1){
            return 1;
        }
        if(dp[m][n]!=-1) return dp[m][n];
        return dp[m][n] = solve(m-1 , n ,dp)+solve(m , n-1,dp);
    }
    int uniquePaths(int m, int n) {
        vector<vector<int>>dp(m+2 , vector<int>(n+2,-1));
        return solve(m,n,dp);
    }
};

63. Unique Paths II(7min)
class Solution {
public:
    int solve(vector<vector<int>>& nums ,vector<vector<int>>& dp ,int i ,int j){
        int n= nums.size() , m = nums[0].size();
        if(i>=n  || j>=m ||nums[i][j]==1) return 0;
        if(i==n-1 && j==m-1) return 1;
        if(dp[i][j]!=-1) return dp[i][j];
        return dp[i][j] =solve(nums, dp ,i+1, j) + solve(nums, dp ,i , j+1);
    }
    int uniquePathsWithObstacles(vector<vector<int>>& nums) {
        vector<vector<int>>dp(nums.size() +2 , vector<int>(nums[0].size()+2,-1));
        return solve(nums ,dp, 0 , 0);
    }
};



